// Copyright by Barry G. Becker, 2013. Licensed under MIT License: http://www.opensource.org/licenses/MIT

import org.apache.tools.ant.filters.ReplaceTokens
import java.text.MessageFormat

version = getVersion()

ext.distributionGameDir="$distributionDir/applets"
ext.distributionSchemaDir="$distributionDir/schema"

/** these dependent jars will be pull from Sonatype where they were published */
dependencies {
    compile "com.barrybecker4:bb4-optimization:$version"
    compile "com.barrybecker4:bb4-sound:$version"
    compile "com.barrybecker4:bb4-sgf:1.1"

    compile "com.barrybecker4:bb4-puzzle:$version"
    compile "com.barrybecker4:bb4-adventure:$version"
    compile "com.barrybecker4:bb4-hiq:$version"
    compile "com.barrybecker4:bb4-maze:$version"
    compile "com.barrybecker4:bb4-redpuzzle:$version"
    compile "com.barrybecker4:bb4-sudoku:$version"
    compile "com.barrybecker4:bb4-tantrix:$version"

    compile "com.barrybecker4:bb4-game-common:$version"
    compile "com.barrybecker4:bb4-twoplayer-common:$version"
    compile "com.barrybecker4:bb4-multiplayer-common:$version"
    compile "com.barrybecker4:bb4-card:$version"
    compile "com.barrybecker4:bb4-chess:$version"
    compile "com.barrybecker4:bb4-blockade:$version"
    compile "com.barrybecker4:bb4-go:$version"
    compile "com.barrybecker4:bb4-pente:$version"
    compile "com.barrybecker4:bb4-tictactoe:$version"
    compile "com.barrybecker4:bb4-galactic:$version"
    compile "com.barrybecker4:bb4-poker:$version"
    compile "com.barrybecker4:bb4-set:$version"

    compile "com.barrybecker4:bb4-simulation:$version"
    compile "com.barrybecker4:bb4-dice:$version"
    compile "com.barrybecker4:bb4-fluid:$version"
    compile "com.barrybecker4:bb4-fractalexplorer:$version"
    compile "com.barrybecker4:bb4-habitat:$version"
    compile "com.barrybecker4:bb4-henonexplorer:$version"
    compile "com.barrybecker4:bb4-liquid:$version"
    compile "com.barrybecker4:bb4-lsystem:$version"
    compile "com.barrybecker4:bb4-predprey:$version"
    compile "com.barrybecker4:bb4-reactiondiffusion:$version"
    compile "com.barrybecker4:bb4-snake:$version"
    compile "com.barrybecker4:bb4-stock:$version"
    compile "com.barrybecker4:bb4-trebuchet:$version"
    compile "com.barrybecker4:bb4-verhulst:$version"

    compile project(':imageproc')
    compile project(':apps')
}

clean.doLast {
    // project. is needed to disambiguate from the clean tasks existing delete.
    project.delete("$distributionDir", "$stagingDir")
}

/**
 * Copy image files used in web deployment to the dist directory
 */
task deployImages(type: Copy, description: "Copy image files to $distributionGameDir")  {
    from "$sourceDir/images"
    into "$distributionGameDir"
    include '**/*.jpg'
    include '**/*.png'
    include '**/*.gif'
}

/**
 * Copy XMl schema files to the dist directory so they can be referenced with an http namespace.
 */
task deploySchemas(type:Copy, description: "Copy schema files to $distributionDir") {

     from fileTree("$project.projectDir").files
     into "$distributionSchemaDir"
     include "**/*.dtd"
     include "**/*.xsd"
}

/**
 * Make sure all the dependent jar files are drawn into the dist directory.
 */
task deployJars(type:Copy, dependsOn: [':apps:copyToLib', ':imageproc:copyToLib', ':webdeployment:copyToLib'],
    description: "Deploys jar files needed for running applets and web start applications")  {

    from fileTree("$project.projectDir/..").include('**/build/libs/**').files
    into "$distributionGameDir"
    include 'bb4-*.jar', 'jhlabs-*.jar', 'bb4-sgf-*.jar', 'jai-codec-*.jar', 'vecmath-*.jar'
    exclude '*-sources.jar', '*-javadoc.jar'
}

/**
 * I would like this to trigger a top level build of everything, but right now it has to be done manually.
 */
task deploy(dependsOn: [deployImages, deploySchemas, deployJars],
    description: "Deploys all files  to $distributionGameDir so they can be bulk copied to a website") << {
    apply from: 'appletHtmlCommon.gradle'

    // copy all the js, css, image files (only done once, not once per locale)
    copy {
        from "$sourceDir/html"
        into "$distributionGameDir/.."
        include '*.js', '*.css', '*.gif'
    }

    println "locales = " + appletHtml.localesList
    appletHtml.localesList.each {
        locale -> createHtmlForLocale(locale)
    }
}

/** read the version from message bundle. It is the version of all the bb4 jars */
String getVersion() {
    def labels = ResourceBundle.getBundle('html', Locale.ENGLISH)
    return labels.getString("version")
}

/**
 * Deploys all the html files for the given locale.
 * This includes the index page, javascript, and individual applet/jnlp files.
 */
void createHtmlForLocale(Locale locale) {

    createHtmlIndexPage(locale)

    // there needs to be a set of html and jnlp files for each locale
    createAppletFilesOfType(html, locale)
    createAppletFilesOfType(jnlp, locale)
}

/**
 * Index pages are created for each language (i.e. locale) supported.
 * @param locale the locale to create an index page for
 */
void createHtmlIndexPage(Locale locale) {
    def labels = ResourceBundle.getBundle('html', locale)
    // make these replacements when copying
    def indexReplacements = getIndexReplacements(labels);
    def entryReplacements = getEntryReplacements(labels);
    def entryKeyReplacements = getEntryKeyReplacements(labels);

    copy {
        from "$sourceDir/html/" + appletIndexFile['base']
        into "$distributionGameDir/.."
        rename { String fileName ->
            fileName.replace('.html', '_' + locale.toString() + '.html')
        }
        filter(ReplaceTokens, tokens: indexReplacements, beginToken: '{', endToken: '}')
        filter(ReplaceTokens, tokens: entryReplacements, beginToken: '{', endToken: '}')
        filter(ReplaceTokens, tokens: entryKeyReplacements, beginToken: '{', endToken: '}')
    }
}

/**
 * Creates either the html applet files or the jnlp webstart files for a specified locale.
 * @param fileTypeMap either html or jnlp message replacements for the individual files (see appletHtmlCommon.gradle)
 * @param locale the locale to create an index page for
 */
void createAppletFilesOfType(Map fileTypeMap, Locale locale) {
    def labels = ResourceBundle.getBundle('html', locale)
    appletHtml.get("appletList").each { String applet ->
        def replacements = getFileTypeReplacements(labels, applet, fileTypeMap)
        copy {
            from "$sourceDir/html/applet_template." + fileTypeMap.get("type")
            into "$distributionGameDir"
            rename { String fileName ->
                fileName.replace('applet_template', applet + '_' + locale.toString())
            }
            filter(ReplaceTokens, tokens: replacements, beginToken: '{', endToken: '}')
        }
    }
}

/**
 * Create a massage replacement map.
 * @param labels
 * @return the index replacements
 */
Map getIndexReplacements(ResourceBundle labels) {
    def replacements = new HashMap()
    htmlIndex.get("replacementList").each {
        key -> if (labels.containsKey(key)) {
            replacements.put(key, labels.getString(key))
        }
    }
    return replacements
}

/**
 * Use parameterized message for html to launch.
 * @return replacements for entries within the index page
 */
Map getEntryReplacements(ResourceBundle labels) {

    def TRTemplate = labels.getString("TRTemplate")
    def replacements = new HashMap()

    appletHtml.get("appletList").each {
        key ->
            def appKey = key + '.name'
            if (labels.containsKey(appKey)) {
                def appName = labels.getString(appKey)
                def titleKey = '{' + key + '.title}'
                def longDescKey = '{' + key + '.longDescription}'
                def loc = labels.getLocale().toString()
                String str = MessageFormat.format(TRTemplate, titleKey, longDescKey, appName, loc)
                replacements.put(key + "TR", str)
        }
    }
    return replacements
}

/**
 * @param labels the message bundle with message keys and values
 * @return entry key replacements
 */
Map getEntryKeyReplacements(ResourceBundle labels) {
    def replacements = new HashMap()
    appletHtml.get("appletList").each { applet ->
        htmlIndex.get("entryKeyReplacementList").each { key ->
            def appletKey = applet + '.' + key;
            replacements.put(appletKey, labels.getString(appletKey))
        }
    }
    return replacements
}

/**
 *
 * @param labels message bundle
 * @param applet name of the applet
 * @param fileType map of keys for either htnml or jnlp
 * @return message replacement map with values taking into account the version
 */
Map getFileTypeReplacements(ResourceBundle labels, String applet, Map fileType) {
    def replacements = new HashMap()

    fileType.get("replacementList").each { String key ->
        def appletKey = applet + '.' + key;
        if (labels.containsKey(appletKey))
            replacements.put(key, MessageFormat.format(labels.getString(appletKey), project.version))
        else
            replacements.put(key, labels.getString(key))
    }

    replacements.put("codebase", codebase)
    return replacements
}

jar {
    // skip building the default jar that contains everything
    enabled = false
}


