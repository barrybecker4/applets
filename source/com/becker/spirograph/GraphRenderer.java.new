package com.becker.spirograph;

import com.becker.java2d.*;
import com.becker.common.*;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

/**
 * Program to simulate a SpiroGraph.
 * Adapted from Divid Little's original work.
 *
 *  to do:
 *   - convert to polar coords
 *   - search the space of images using a genetic algorithm
 *
 * @author David Little
 * @author Barry Becker
 */

public class GraphRenderer extends JPanel implements Runnable
{
    public static final int HT = 1000, WD = 1200;

    private static final Color AXES_COLOR = new Color(120, 120, 200);
    private static final Color CIRCLE_COLOR = new Color(90, 90, 150);

    public static volatile Thread thread_ = null;

    private BufferedImage offImage_;
    private Graphics2D offlineGraphics_;
    private double[] center_;

    // set this var instead of using Thread.stop (see
    // http://java.sun.com/products/jdk/1.2/docs/guide/misc/threadPrimitiveDeprecation.html )
    private boolean paused_ = false;
    private final Object pauseLock_ = new Object(); // monitor

    private GraphState state_;
    private JButton drawButton_;

    GraphRenderer(GraphState state, JButton drawButton)
    {
        drawButton_ = drawButton;
        commonConstructor(state);
    }

    private void commonConstructor(GraphState state)
    {
        state_ = state;
        setBackground( Color.white );
        center_ = new double[2];
        state_.setX((float)((WD >> 1) + state_.getR1() + (state_.getR2() + state_.getSign()) + state_.getPos()));
        state_.setY(HT >> 1);
        state_.recordValues();

        //System.out.println( "the image w =" + WD + " h=" + HT );
        offImage_ = ImageUtil.createCompatibleImage( WD, HT );
        if ( offImage_ != null ) {
            offlineGraphics_ = offImage_.createGraphics();
            offlineGraphics_.setRenderingHint( RenderingHints.KEY_ANTIALIASING,
                    RenderingHints.VALUE_ANTIALIAS_ON );
            offlineGraphics_.setRenderingHint( RenderingHints.KEY_RENDERING,
                    RenderingHints.VALUE_RENDER_QUALITY );
            offlineGraphics_.setRenderingHint( RenderingHints.KEY_COLOR_RENDERING,
                    RenderingHints.VALUE_COLOR_RENDER_QUALITY );
        }
        else {
            System.out.println( "error the offImage is null!" );
        }
        clear();
    }

    /**
     * starts the rendering thread.
     */
    public void run()
    {
        Thread thisThread = Thread.currentThread();
        while ( thread_ == thisThread ) {
            doRendering();
        }
    }

    private synchronized void doRendering()
    {
        int count = 0;
        initializeValues();
        boolean refresh = false;

        double r1 = state_.getR1();
        double r2 = state_.getR2();
        double p = state_.getPos();
        double sign = state_.getSign();

        if ( r2 == 0 ) return; // avoid degenerate case - div by 0

        int revs = (int) (sign * r2) / MathUtil.gcd( (int) r1, (int) (sign * r2) );

        Stroke thinStroke = new BasicStroke( 1 );
        offlineGraphics_.setPaintMode();

        double n = 1.0 + state_.getNumSegmentsPerRev() * (Math.abs( p / r2 ));

        while ( count++ < (int) (n * revs + 0.5) ) {
            r1 = state_.getR1();
            r2 = state_.getR2();
            p = state_.getPos();
            offlineGraphics_.setColor( state_.getColor() );

            if ( count == (int) (n * revs + 0.5) )
                state_.setTheta(0.0f);
            else
                state_.setTheta((float) (2.0 * Math.PI * count / n));
            double theta = state_.getTheta();
            state_.setPhi((float)(theta * (1.0 + r1 / r2)));
            double phi = state_.getPhi();
            setPoint(p, phi);

            double oldx = state_.getOldX();
            double oldy = state_.getOldY();

            if (state_.showAxes() && refresh ) {
                // erase the old indicators
                double oldR1 = state_.getOldR1();
                double oldR2 = state_.getOldR2();
                double oldSign = state_.getOldSign();
                double oldPhi = state_.getOldPhi();
                double oldTheta = state_.getOldTheta();

                offlineGraphics_.setStroke( thinStroke );
                drawCircle2( oldR1, oldR2, oldSign, oldTheta );
                //drawDot( oldR1, oldR2, oldSign, oldTheta, state_.getOldPos(), oldPhi );
                // @@ this will set x and y in state to oldx and oldy (how did this work before?)
                double x = state_.getX();
                double y = state_.getY();
                //drawLineToDot( oldR1, oldR2, oldSign, state_.getOldPos(), oldTheta, oldPhi, oldx, oldy );
                state_.setX((float)x);
                state_.setY((float)y);
                offlineGraphics_.setPaintMode();
                offlineGraphics_.setColor( state_.getColor() );
            }
            waitIfPaused();
            int velocity = state_.getVelocity();
            refresh = (count % (velocity) == 0) && (velocity != GraphState.VELOCITY_MAX);

            Stroke stroke = new BasicStroke( (float) state_.getWidth() / GraphState.INITIAL_LINE_WIDTH );
            offlineGraphics_.setStroke( stroke );
            offlineGraphics_.drawLine( (int) oldx, (int) oldy, (int) state_.getX(), (int) state_.getY() );

            if ( state_.showAxes() && refresh ) {
                offlineGraphics_.setXORMode( getBackground() );
                offlineGraphics_.setColor( CIRCLE_COLOR );
                offlineGraphics_.setStroke( thinStroke );
                drawCircle2( r1, r2, sign, theta );
                //drawDot( r1, r2, sign, theta, p, phi );
                //drawLineToDot( r1, r2, sign, p, theta, phi, state_.getX(), state_.getY() );
            }
            if ( refresh ) {
                //System.out.println("ct="+count+" v="+v);
                if ( velocity < 20 ) {
                    try {
                        Thread.sleep( 200 / velocity );
                    } catch (InterruptedException e) {}
                }
                repaint();
            }

            state_.recordValues();
        }
        repaint();
        drawButton_.setText( SpiroGraph.DRAW_LABEL );
        thread_ = new Thread( this );
    }

    public void setPaused( boolean newPauseState )
    {
        synchronized (pauseLock_) {
            if ( paused_ != newPauseState ) {
                paused_ = newPauseState;
                pauseLock_.notifyAll();
            }
        }
    }

    private synchronized void waitIfPaused()
    {
        if ( !paused_ ) return;
        // pause if we get suspended
        try {
            synchronized (pauseLock_) {
                while ( paused_ ) pauseLock_.wait();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void update( Graphics g )
    {
        paint( g );
    }

    public void paint( Graphics g )
    {
        g.drawImage( offImage_, (getSize().width - WD) >> 1, (getSize().height - HT) >> 1, this );
    }

    public void initializeValues()
    {
        state_.setSign(state_.getR2() < 0 ? -1:1);
        state_.setTheta(0.0f);
        state_.setPhi(0.0f);
        state_.setX((float)((WD >> 1) + state_.getR1() + state_.getR2() + state_.getSign() + state_.getPos()));
        state_.setY(HT >> 1);
        state_.recordValues();
    }

    /**
     * @@ has side effect of setting x and y in state.
     * @param p
     * @param phi
     */
    public void setPoint(double p, double phi)
    {
        setCenter( state_.getR1(), state_.getR2(), state_.getSign(), state_.getTheta() );
        state_.setX((float)(center_[0] + p * Math.cos( phi )));
        state_.setY((float)(center_[1] - p * Math.sin( phi )));
    }

    public void setCenter( double r1, double r2, double sign, double theta )
    {
        center_[0] = (WD >> 1) + (r1 + r2 + sign) * Math.cos( theta );  // + sign?
        center_[1] = (HT >> 1) - (r1 + r2 + sign) * Math.sin( theta );
    }

    public void clear()
    {
        if ( offlineGraphics_ == null )
            return;
        offlineGraphics_.setPaintMode();
        offlineGraphics_.setColor( getBackground() );
            offlineGraphics_.fillRect( 0, 0, WD, HT );
        drawAxes();
    }

    public void drawAxes()
    {
        if ( state_.showAxes() ) {

            offlineGraphics_.setXORMode( getBackground() );
            offlineGraphics_.setColor( AXES_COLOR );
            offlineGraphics_.drawLine( WD >> 1, 0, WD >> 1, HT );
            offlineGraphics_.drawLine( 0, HT >> 1, WD, HT >> 1 );
            offlineGraphics_.setColor( CIRCLE_COLOR );
            double r1 = state_.getR1();
            double r2 = state_.getR2();
            double p = state_.getPos();
            double sign = state_.getSign();
            double theta = state_.getTheta();
            double phi = state_.getPhi();
            drawCircle1( r1 );
            drawCircle2( r1, r2, sign, theta );
            drawDot( r1, r2, sign, theta, p, phi );
            drawLineToDot( r1, r2, sign, p, theta, phi, state_.getX(), state_.getY() );
        }
        repaint();
    }



    public void adjustCircle1()
    {
        if ( state_.showAxes() ) {
            drawCircle1( state_.getOldR1() );
            drawCircle1( state_.getR1() );
            adjustCircle2();
        }
        else
            state_.recordValues();
    }

    public void adjustCircle2()
    {
        if ( state_.showAxes() ) {
            drawCircle2( state_.getOldR1(), state_.getOldR2(), state_.getOldSign(), state_.getOldTheta() );
            drawCircle2( state_.getR1(), state_.getR2(), state_.getSign(), state_.getTheta() );
            adjustDot();
        }
        else
            state_.recordValues();
    }

    public void adjustDot()
    {
        if ( state_.showAxes() ) {
            drawDot( state_.getOldR1(), state_.getOldR2(),
                     state_.getOldSign(), state_.getOldTheta(), state_.getOldPos(), state_.getOldPhi() );
            drawDot( state_.getR1(), state_.getR2(),
                     state_.getSign(), state_.getTheta(), state_.getPos(), state_.getPhi() );
            adjustLineToDot();
        }
        else {
            state_.recordValues();
        }
    }

    public void adjustLineToDot()
    {
        drawLineToDot( state_.getOldR1(), state_.getOldR2(),
                       state_.getOldSign(), state_.getOldPos(), state_.getOldTheta(), state_.getOldPhi(),
                       state_.getOldX(), state_.getOldY() );
        drawLineToDot( state_.getR1(), state_.getR2(),
                       state_.getSign(), state_.getPos(), state_.getTheta(), state_.getPhi(),
                       state_.getX(), state_.getY() );
        state_.recordValues();
        repaint();
    }

    private void drawCircle1( double r1 )
    {
        offlineGraphics_.drawOval( (int) ((WD >> 1) - r1), (int) ((HT >> 1) - r1), (int) (2 * r1), (int) (2 * r1) );
    }

    private void drawCircle2( double r1, double r2, double sign, double theta )
    {
        setCenter( r1, r2, sign, theta );
        offlineGraphics_.drawOval( (int) (center_[0] - sign * r2), (int) (center_[1] - sign * r2),
                       (int) (2 * sign * r2), (int) (2 * sign * r2) );
    }

    private void drawDot( double r1, double r2, double sign, double theta, double p, double phi )
    {
        setCenter( r1, r2, sign, theta );
        offlineGraphics_.fillOval( (int) (center_[0] + p * Math.cos( phi )) - 2,
                (int) (center_[1] - p * Math.sin( phi )) - 2,
                5, 5 );
    }

    private void drawLineToDot( double r1, double r2, double sign, double p, double theta, double phi, double x, double y )
    {
        setCenter( r1, r2, sign, theta );
        double side = sign;
        if ( p < 0 ) side = -sign;

        offlineGraphics_.drawLine( (int) (center_[0] + side * r2 * Math.cos( phi )),
                (int) (center_[1] - side * r2 * Math.sin( phi )),
                (int) x, (int) y );
        setPoint(p, phi);
    }

    public void reset() {
        // stop the thread
        thread_ = null;

        state_.setTheta(0.0f);
        state_.setPhi(0.0f);
        setPoint(state_.getPos(), 0);
        adjustCircle2();
    }

}