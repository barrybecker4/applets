<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
   <title>Red Puzzle</title>
</head>
<body>

<h1>
Red Puzzle Solver</h1>
The Red Puzzle (Also Called "One Tough Puzzle" from Great American Puzzle
Factory, Inc) is a 9 piece jigsaw puzzle. It is very hard because every
piece has four nubs. There are no edge pieces. There are over 300,000 incorrect
configurations. This applet will solve it in about 10,000 - 60,000 iterations.
It shuffles the pieces so there is a different result each time. The search
algorithm tries pieces until it finds one that doesn't fit. If none of
the remaining pieces fit after all rotations have been tried, it backtracks
one position and tries again. Its guaranteed to find a solution if there
is one. The letters indicate the shape of the nub: Heart, Diamond, Club
or Spade. Maybe someday I will draw the pieces as they really look.
<p>com.becker.redpuzzle.RedPuzzle will appear below in a Java enabled browser.
<br>
<object classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" width="300" height="300" align="Baseline" 
  codebase="http://java.sun.com/products/plugin/1.3/jinstall-13-win32.cab#Version=1,3,0,0"><param name="code"   value="com.becker.redpuzzle.RedPuzzle"><param name="codebase" value="."><param name="archive"   value="common.jar,redpuzzle.jar"><param name="name" value="RedPuzzle"><param name="type"     value="application/x-java-applet;version=1.3"><param name="scriptable" value="true">
    NoJava 2 SDK, Standard Edition v 1.3+ support for APPLET!!&nbsp;
</object>
<br>
<hr>
<pre>

/*
 * Here's the recursive java method for finding the solution. 
 */
protected static boolean <b>solvePuzzle</b>(Solution solution, List pieces) 
  {
     solution.paint(solution.getGraphics());
     boolean solved = false;
     int numPiecesRemaining = pieces.size();
     
     if (numPiecesRemaining == 0)
         return true;
    
     int k = 0;
     while (!solved  && (k < numPiecesRemaining)) {
         Piece p = (Piece)pieces.get(k);
         if (solution.fits( p )) {
             solution.push( p );
             pieces.remove( p );
             solved = solvePuzzle(solution, pieces);
             if (!solved) {
                 // then we still need to try the remaining rotations for
                 // that first piece
                 p = solution.pop();
                 if (solution.fits( p ))  { // checks remaining rotations
                     solution.push( p );
                     solved = <b>solvePuzzle</b>(solution, pieces);
                 }
                 if (!solved) {
                     // if still not solved we need to back track
                     p = solution.pop();
                     p.reset(); // restore to unrotated state
                     pieces.add( k, p );  // put it back where it came from
                     solution.paint();    // shows a frame of the animation
                }
             }
         }
       
         k++;
         numIterations_++;
     }
     // if we get here and solved is not true, we did not find a solution
     return solved;
  }

 
  main{
     numIterations_ = 0;
     solution_ = new Solution();
     pieces_ = new ArrayList();
      
     // these are the pieces.
     pieces_.add(new Piece('S', 'H', 'S', 'D',  false, false, true, true, 1));
     pieces_.add(new Piece('H', 'S', 'S', 'C',  true, true, false, false, 2));
     pieces_.add(new Piece('H', 'D', 'D', 'H',  true, true, false, false, 3));    
     pieces_.add(new Piece('H', 'D', 'C', 'C',  true, true, false, false, 4));
     pieces_.add(new Piece('C', 'H', 'S', 'H',  true, true, false, false, 5));
     pieces_.add(new Piece('C', 'H', 'D', 'C',  true, true, false, false, 6));    
     pieces_.add(new Piece('S', 'D', 'H', 'D',  true, true, false, false, 7));
     pieces_.add(new Piece('D', 'C', 'C', 'D',  true, true, false, false, 8));
     pieces_.add(new Piece('S', 'S', 'H', 'C',  true, true, false, false, 9));
      
     // shuffle the pieces so we get difference solutions -
     // or at least different approaches to the solution if there is only one.
     Collections.shuffle(pieces_);
      
     // this does all the heavy work of solving it
     boolean solved = <b>solvePuzzle</b>(solution_, pieces_);
  }
</pre>
<br>
</body>
</html>
