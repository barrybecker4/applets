// Copyright by Barry G. Becker, 2013. Licensed under MIT License: http://www.opensource.org/licenses/MIT

import org.apache.tools.ant.filters.ReplaceTokens
import java.text.MessageFormat

apply from: 'https://raw.github.com/barrybecker4/bb4-common/master/bb4.gradle'
mainClassName = "com.barrybecker4.common.format.CurrencyFormatter"

ext.distributionAppletsDir="$distributionDir/applets"
ext.distributionSchemaDir="$distributionDir/schema"


/** these dependent jars will be pull from Sonatype where they were published */
dependencies {
    println("depVersion =  $depVersion")
    compile "com.barrybecker4:bb4-optimization:$depVersion"
    compile "com.barrybecker4:bb4-sound:$depVersion"
    compile "com.barrybecker4:bb4-sgf:1.1"

    compile "com.barrybecker4:bb4-puzzle:$depVersion"
    compile "com.barrybecker4:bb4-adventure:$depVersion"
    compile "com.barrybecker4:bb4-hiq:$depVersion"
    compile "com.barrybecker4:bb4-maze:$depVersion"
    compile "com.barrybecker4:bb4-redpuzzle:$depVersion"
    compile "com.barrybecker4:bb4-sudoku:$depVersion"
    compile "com.barrybecker4:bb4-tantrix:$depVersion"
    compile "com.barrybecker4:bb4-bridge:$depVersion"
    compile "com.barrybecker4:bb4-slidingpuzzle:$depVersion"
    compile "com.barrybecker4:bb4-twopails:$depVersion"

    compile "com.barrybecker4:bb4-game:$depVersion"
    compile "com.barrybecker4:bb4-twoplayer:$depVersion"
    compile "com.barrybecker4:bb4-multiplayer:$depVersion"
    compile "com.barrybecker4:bb4-chess:$depVersion"
    compile "com.barrybecker4:bb4-blockade:$depVersion"
    compile "com.barrybecker4:bb4-go:$depVersion"
    compile "com.barrybecker4:bb4-gomoku:$depVersion"
    compile "com.barrybecker4:bb4-tictactoe:$depVersion"
    compile "com.barrybecker4:bb4-galactic:$depVersion"
    compile "com.barrybecker4:bb4-poker:$depVersion"
    compile "com.barrybecker4:bb4-set:$depVersion"
    compile "com.barrybecker4:bb4-mancala:$depVersion"
    compile "com.barrybecker4:bb4-hex:$depVersion"

    compile "com.barrybecker4:bb4-simulation:$depVersion"
    compile "com.barrybecker4:bb4-dice:$depVersion"
    compile "com.barrybecker4:bb4-fluid:$depVersion"
    compile "com.barrybecker4:bb4-fractalexplorer:$depVersion"
    compile "com.barrybecker4:bb4-habitat:$depVersion"
    compile "com.barrybecker4:bb4-henonexplorer:$depVersion"
    compile "com.barrybecker4:bb4-cave:$depVersion"
    compile "com.barrybecker4:bb4-conway:$depVersion"
    compile "com.barrybecker4:bb4-liquid:$depVersion"
    compile "com.barrybecker4:bb4-lsystem:$depVersion"
    compile "com.barrybecker4:bb4-predprey:$depVersion"
    compile "com.barrybecker4:bb4-reactiondiffusion:$depVersion"
    compile "com.barrybecker4:bb4-snake:$depVersion"
    compile "com.barrybecker4:bb4-stock:$depVersion"
    compile "com.barrybecker4:bb4-trading:$depVersion"
    compile "com.barrybecker4:bb4-trebuchet:$depVersion"
    compile "com.barrybecker4:bb4-verhulst:$depVersion"

    compile project(':imageproc')
    compile project(':apps')
}

clean.doLast {
    // project. is needed to disambiguate from the clean tasks existing delete.
    project.delete("$distributionDir", "$stagingDir")
}

/**
 * Copy image files used in web deployment to the dist directory
 */
task deployImages(type: Copy, description: "Copy image files to $distributionAppletsDir")  {
    from "$sourceDir/images"
    into "$distributionAppletsDir"
    include '*.jpg', '*.png', '*.gif'
}

/**
 * Copy XMl schema files to the dist directory so they can be referenced with an http namespace.
 */
task deploySchemas(type:Copy, description: "Copy schema files to $distributionDir") {

     from fileTree("$project.projectDir/..").include("**/*.dtd", "**/*.xsd").files
     into "$distributionSchemaDir"
}

/**
 * Make sure all the dependent jar files are drawn into the dist directory.
 */
task deployJars(type:Copy, dependsOn: ['signJars', 'copyToLib'],
    description: "Deploys jar files needed for running applets and web start applications")  {

    from fileTree("$project.projectDir/..").include('**/build/libs/**').files
    into "$distributionAppletsDir"
    include 'bb4-*.jar', 'jhlabs-*.jar', 'bb4-sgf-*.jar', 'vecmath-*.jar', 'scala-library-*.jar'
    exclude '*-sources.jar', '*-javadoc.jar'
}


task buildHtml(description: "creates the html files from templates and locale bundles") {
    doLast {
        apply from: 'appletHtmlCommon.gradle'

        println "locales = " + appletHtml.localesList
        appletHtml.localesList.each {
            locale -> createHtmlForLocale(locale)
        }

        // copy all the js, css, image files (only done once, not once per locale)
        copy {
            from "$sourceDir/html"
            into "$distributionAppletsDir/.."
            include '*.js', '*.css', '*.gif', '*.png', '*.jpg'
        }
    }
}


/**
 * I would like this to trigger a top level build of everything, but right now it has to be done manually.
 */
task deploy(dependsOn: [deployImages, deploySchemas, deployJars, buildHtml],
    description: "Deploys all files  to $distributionAppletsDir so they can be bulk copied to a website") {
}

/**
 * Must sign all jars that are deployed or applets/webstart will complain.
 * This step requires having a keystore with a certificate
 *
 * First setup a keystore using something like this
 *
 * keytool -genkeypair -dname "cn=Barry G Becker, ou=software, o=barrybecker4, c=US"
 *  -alias bb4 -keypass g****4 -keystore C:/users/becker/bb4-keystore -storepass g****4 -validity 999999
 *
 * Then sign with
 * jarsigner bb4-common-$depVersion.jar -tsa http://timestamp.digicert.com bb4
 *
 * see these references for more info
 *   http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html
 *   https://docs.oracle.com/javase/tutorial/deployment/jar/signing.html
 */
task signJars {
    doLast {
        def filesToSign = fileTree(dir: 'build/libs', include: "*.jar")
        filesToSign.each { jarName ->
            println "about to sign " + jarName

            ant.signjar(
                alias: "bb4",
                jar: jarName,
                tsaurl: 'http://timestamp.digicert.com',
                keystore: "C:/users/barry/bb4-keystore",
                storepass: "green4",
                //storetype: "pkcs12",
                verbose: true
            )
        }
    }
}


/**
 * Deploys all the html files for the given locale.
 * This includes the index page, javascript, and individual applet/jnlp files.
 */
void createHtmlForLocale(Locale locale) {

    createHtmlIndexPage(locale)

    // there needs to be a set of html and jnlp files for each locale
    createAppletFilesOfType(html, locale)
    createAppletFilesOfType(jnlp, locale)
}

/**
 * Index pages are created for each language (i.e. locale) supported.
 * @param locale the locale to create an index page for
 */
void createHtmlIndexPage(Locale locale) {
    def labels = ResourceBundle.getBundle('html', locale)
    // make these replacements when copying
    def indexReplacements = getIndexReplacements(labels);
    def entryReplacements = getEntryReplacements(labels);
    def entryKeyReplacements = getEntryKeyReplacements(labels);

    copy {
        from "$sourceDir/html/" + appletIndexFile['base']
        into "$distributionAppletsDir/.."
        rename { String fileName ->
            fileName.replace('.html', '_' + locale.toString() + '.html')
        }
        filter(ReplaceTokens, tokens: indexReplacements, beginToken: '{', endToken: '}')
        filter(ReplaceTokens, tokens: entryReplacements, beginToken: '{', endToken: '}')
        filter(ReplaceTokens, tokens: entryKeyReplacements, beginToken: '{', endToken: '}')
    }
}

/**
 * Creates either the html applet files or the jnlp webstart files for a specified locale.
 * @param fileTypeMap either html or jnlp message replacements for the individual files (see appletHtmlCommon.gradle)
 * @param locale the locale to create an index page for
 */
void createAppletFilesOfType(Map fileTypeMap, Locale locale) {
    def labels = ResourceBundle.getBundle('html', locale)
    appletHtml.get("appletList").each { String applet ->
        def replacements = getFileTypeReplacements(labels, applet, fileTypeMap)
        copy {
            from "$sourceDir/html/applet_template." + fileTypeMap.get("type")
            into "$distributionAppletsDir"
            rename { String fileName ->
                fileName.replace('applet_template', applet + '_' + locale.toString())
            }
            filter(ReplaceTokens, tokens: replacements, beginToken: '{', endToken: '}')
        }
    }
}

/**
 * Create a massage replacement map.
 * @param labels
 * @return the index replacements
 */
Map getIndexReplacements(ResourceBundle labels) {
    def replacements = new HashMap()
    htmlIndex.get("replacementList").each {
        key -> if (labels.containsKey(key)) {
            replacements.put(key, labels.getString(key))
        }
    }
    return replacements
}

/**
 * Use parameterized message for html to launch.
 * @return replacements for entries within the index page
 */
Map getEntryReplacements(ResourceBundle labels) {

    def TRTemplate = labels.getString("TRTemplate")
    def replacements = new HashMap()

    appletHtml.get("appletList").each {
        key ->
            def appKey = key + '.name'
            if (labels.containsKey(appKey)) {
                def appName = labels.getString(appKey)
                def titleKey = '{' + key + '.title}'
                def longDescKey = '{' + key + '.longDescription}'
                def loc = labels.getLocale().toString()
                String str = MessageFormat.format(TRTemplate, titleKey, longDescKey, appName, loc)
                replacements.put(key + "TR", str)
        }
    }
    return replacements
}

/**
 * @param labels the message bundle with message keys and values
 * @return entry key replacements
 */
Map getEntryKeyReplacements(ResourceBundle labels) {
    def replacements = new HashMap()
    appletHtml.get("appletList").each { applet ->
        htmlIndex.get("entryKeyReplacementList").each { key ->
            def appletKey = applet + '.' + key;
            replacements.put(appletKey, labels.getString(appletKey))
        }
    }
    return replacements
}

/**
 *
 * @param labels message bundle
 * @param applet name of the applet
 * @param fileType map of keys for either html or jnlp
 * @return message replacement map with values taking into account the version
 */
Map getFileTypeReplacements(ResourceBundle labels, String applet, Map fileType) {
    def replacements = new HashMap()

    fileType.get("replacementList").each { String key ->
        def appletKey = applet + '.' + key;
        if (labels.containsKey(appletKey))
            replacements.put(key, MessageFormat.format(labels.getString(appletKey), depVersion))
        else
            replacements.put(key, labels.getString(key))
    }

    replacements.put("codebase", codebase)
    replacements.put("scalaVersion", scalaVersion)
    replacements.put("vecmathVersion", vecmathVersion)
    return replacements
}

jar {
    // skip building the default jar that contains everything
    enabled = false
}
